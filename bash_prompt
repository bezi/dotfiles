#!/bin/bash
# @file ~/.bash_prompt
# @brief sets my custom bash prompt
# @author Oscar Bezi (oscar@bezi.io)
# @since 5 June 2014
#===============================================================================

# customisation for the prompt
function bash_prompt {
    # make sure there's no scoping issues
    local LOCATION; # contains the output of `pwd`
    local INFO; # contains the username and hostname
    local DIRS; # contains the directories in the current directory
    local PROMPT;
    local LENGTH="$COLUMNS"; # number of dashed to fill the line
    local STATUS=$1; # status of last command ran
    local GIT_REPO_INFO="";
    local SVN_REPO_INFO=""; 
    local LINE_COLOR="$BWhite";

    # make sure to subtract 3 from length every time this is called
    function wrap_things {
        echo "$Purple[$*$Purple]$LINE_COLOR─";
    }

    
    # Information string
    LENGTH=$(($LENGTH - 2 - ${#USER} - ${#HOSTNAME} - 3));
    INFO=`wrap_things $BYellow$USER$White::$BGreen$HOSTNAME`; 


    # Dirs
    DIRS=`ls -d --color=never */ 2>/dev/null | sed -e "s/\///"`; 

    # Repository information
    local GIT_INFO=`git status 2>&1`;
    
    if [ "`echo $GIT_INFO | grep 'fatal'`" == "" ]; then
        # we're in a git repo
        local REPO_NAME=`git rev-parse --show-toplevel 2>&1 | awk '{print $1}'`;
        REPO_NAME="${REPO_NAME##*/}";
        local REPO_TYPE="git";
        local REPO_BRANCH=`echo $GIT_INFO | grep 'On branch' | awk '{print $3}'`;
        local STATUS_COLOR=`echo $GIT_INFO | grep 'working directory clean'`;
        local AHEAD=`git status | grep "ahead" | awk '{ print $(NF - 1) }'`;
        
        if [ "$STATUS_COLOR" == "" ]; then
            STATUS_COLOR="$Red";
        else
            STATUS_COLOR="$Green";
        fi

        LENGTH=$(($LENGTH - ${#REPO_TYPE} - 2));
        GIT_REPO_INFO="$Yellow$REPO_TYPE$White::";

        LENGTH=$(($LENGTH - ${#REPO_NAME} - 2));
        GIT_REPO_INFO="$GIT_REPO_INFO$STATUS_COLOR$REPO_NAME$White::";

        LENGTH=$(($LENGTH - ${#REPO_BRANCH})); 
        GIT_REPO_INFO="$GIT_REPO_INFO$STATUS_COLOR$REPO_BRANCH";

        if [ "$AHEAD" != "" ]; then
            LENGTH=$(($LENGTH - ${#AHEAD} - 3));
            GIT_REPO_INFO="$GIT_REPO_INFO$BCyan(+$AHEAD)";
        fi
        LENGTH=$(($LENGTH - 3));
        GIT_REPO_INFO=`wrap_things $GIT_REPO_INFO`;
    fi

    local SVN_INFO=`svn info 2>&1`;
    if [ "`echo $SVN_INFO | grep '\(not a working copy\)\|\(was not found\)'`" == "" ]; then
        # we're in an svn repo!
        local REPO_NAME=`echo $SVN_INFO | sed -e 's/^.*Repository Root: //' -e 's/ .*$//'`;
        REPO_NAME="${REPO_NAME##*/}";
        local REPO_TYPE="svn";
        local REPO_BRANCH=`echo $SVN_INFO | sed -e 's/^.*Working Copy Root Path: //' -e 's/ .*$//'`;
        REPO_BRANCH="${REPO_BRANCH##*/}"; 
        local STATUS_COLOR=`svn status | grep "\(^M\)\|\(^A\)\|\(^\!\)\|\(^D\)" | wc -l`;
        local NUM_CHANGED="";
        if [ "$STATUS_COLOR" == "0" ]; then
            STATUS_COLOR="$Green";
        else
            NUM_CHANGED="$STATUS_COLOR";
            STATUS_COLOR="$Red";
        fi
        LENGTH=$(($LENGTH - ${#REPO_TYPE} - 2));
        SVN_REPO_INFO="$Yellow$REPO_TYPE$White::";

        LENGTH=$(($LENGTH - ${#REPO_NAME} - 2));
        SVN_REPO_INFO="$SVN_REPO_INFO$STATUS_COLOR$REPO_NAME$White::";

        LENGTH=$(($LENGTH - ${#REPO_BRANCH})); 
        SVN_REPO_INFO="$SVN_REPO_INFO$STATUS_COLOR$REPO_BRANCH";

        if [ "$NUM_CHANGED" != "" ]; then
            LENGTH=$(($LENGTH - ${#NUM_CHANGED} - 3));
            SVN_REPO_INFO="$SVN_REPO_INFO$BCyan(+$NUM_CHANGED)";
        fi

        LENGTH=$(($LENGTH - 3));
        SVN_REPO_INFO=`wrap_things $SVN_REPO_INFO`;
    fi

    # Location info
    LOCATION=${PWD##*/};
    if [[ "$LOCATION" == "$USER" ]]; then
        LOCATION="~";
    fi

    LENGTH=$(($LENGTH - ${#LOCATION} - 3));
    LOCATION=`wrap_things $BCyan$LOCATION`;

    # Status codes
    if [ "$STATUS" == "0" ]; then
        STATUS="$Green:)";
    else
        STATUS="$Red:(";
    fi
    LENGTH=$(($LENGTH - 2 - 3));
    STATUS=`wrap_things $STATUS`;

    # combine the first bits
    LENGTH=$(($LENGTH - 2));
    PROMPT="$LINE_COLOR┌─$INFO$GIT_REPO_INFO$SVN_REPO_INFO$LOCATION$LINE_COLOR";

    # the ─┘ characters at the end
    LENGTH=$(($LENGTH - 2));

    # only display the DIRS if the length is not too long
    if [ "$((${#DIRS} + 3))" -le "$LENGTH" ]; then
        LENGTH=$(($LENGTH - ${#DIRS} - 3));
        DIRS=`for i in $DIRS; do echo -n $BBlue$i$White-; done;`
        DIRS=${DIRS%?}; # remove the last -
        PROMPT="$PROMPT`wrap_things $DIRS`";
    else
        LENGTH=$(($LENGTH - 6));
        PROMPT="$PROMPT`wrap_things $BBlue...`";
    fi
    
    # fill up the rest of the line
    while [ $LENGTH -gt 0 ]; do
        PROMPT="$PROMPT─";
        LENGTH=$((LENGTH - 1));
    done;

    PROMPT="$PROMPT$STATUS$LINE_COLOR─┘";

    # second line
    PROMPT="$PROMPT\n$LINE_COLOR└─";
    PROMPT="$PROMPT`wrap_things $White\\\!`";
    PROMPT="$PROMPT$LINE_COLOR──╼";
    printf "$PROMPT$White ";
}

# it's a prompt command to make it execute properly every time
PROMPT_COMMAND='PS1="$(bash_prompt $?)"';
